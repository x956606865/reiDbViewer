# 查询页 API 脚本执行功能开发方案

## 背景与目标

- 当前查询页仅支持执行 SQL 并在应用内展示结果，缺少面向外部系统的自动化对接能力。
- 用户希望在查询结果生成后，将结果按批次调用指定的 HTTP API，以实现对下游服务的数据同步或批量处理。
- 新功能需提供脚本化配置、可控的节流与错误处理策略，并能在任务完成后生成本地文件供下载。

## 术语说明

- **API 脚本**：对某个查询的外部调用配置，包含请求参数、节流策略与错误处理规则。
- **批次拉取数量 (fetchSize)**：单次从数据库再次拉取的最大行数。
- **批次发送数量 (sendBatchSize)**：单次 HTTP 请求发送的记录条数。
- **睡眠间隔 (sleepMs)**：每次请求后暂停的毫秒数，用于节流。
- **请求超时 (requestTimeoutMs)**：等待 API 响应的最大时长。

## 用户场景

- 用户在查询页编写 SQL 并验证结果后，打开脚本配置面板，为该查询定义多个 API 脚本。
- 执行任务时，用户选择某个脚本，应用按照配置对查询结果进行批处理并调用外部 API，直至全部数据处理完毕。
- 任务完成后，应用提供处理结果（成功/失败记录）打包成文件，供用户保存到本地磁盘。

## 功能需求拆解

### 脚本管理

- 支持为每个查询保存多个脚本；脚本至少包含：名称、描述（可选）、API 地址、HTTP 方法（GET/POST/PUT/PATCH/DELETE）、请求头自定义、批次拉取数量、批次发送数量、请求超时、睡眠间隔、错误处理策略（忽略并记录/立即中止）。
- 批次参数限制：`fetchSize`、`sendBatchSize` 范围为 `1~1000`，`sleepMs` 范围 `0~600000`，`requestTimeoutMs` 范围 `1000~600000`。
- 请求头支持多组 key/value，键值需要去重（忽略大小写）并通过格式校验，只允许字母、数字与 `-`。
- 请求体模板（可选）：首版仅支持固定 JSON 结构，可引用当前批次记录数组；留空时默认以 `application/json` 发送原始数组。
- 脚本配置持久化到本地 `app_prefs`（SQLite），与查询 ID 关联，可导入/导出，名称在同一查询下需唯一。

### 脚本执行

- 脚本执行入口位于查询结果区域，支持「选择脚本 + 执行」操作。
- 执行前校验：确认 SQL 最近执行成功且存在结果集；否则提示用户先执行 SQL。
- 批处理流程：
  1. 按 `fetchSize` 重新对数据库分页拉取结果，可复用查询引擎并附带稳定排序（默认追加主键或 `ROW_NUMBER()`）。
  2. 将每批结果按 `sendBatchSize` 拆分为若干请求体。
  3. 依次调用 API，使用配置的 HTTP 方法、请求头和请求体（支持 JSON/表单等可扩展类型）。
  4. 每次请求后遵循 `sleepMs` 节流策略，再进入下一次请求。
- 超时与重试：若请求超时或返回非 2xx，按照错误策略决定「记录并继续」或「立即终止任务」。可选参数决定是否尝试固定次数重试（需在需求确认阶段评估是否纳入首版）。
- 任务执行期间提供进度反馈（总批次数、已完成批次、成功/失败计数），需支持用户手动取消。

### 结果归档

- 成功和失败记录分别写入 CSV，当记录数超过设定阈值（默认 50k 行）时按 `Part-x` 自动切分。
- 执行结束后，将所有结果 CSV、`manifest.json`（包含脚本快照、统计摘要，敏感 header 需脱敏展示）及错误日志打包成 ZIP，提示用户选择保存路径。
- 提供任务日志查看：展示批次级别的请求状态、响应码、耗时和错误摘要。

## 非功能需求

- 数据安全：仅允许只读查询；HTTP 请求需提示用户自行确认目标 API 的安全性。
- 性能：默认节流配置避免对外部服务造成压力，允许用户调整但需有合理上限（例如 `fetchSize/sendBatchSize` 最大 1000）。
- 健壮性：任务异常中断时，应保证临时文件关闭并可清理；下次启动应用可提示是否清理历史任务缓存。

## UI/UX 改动

- **脚本配置抽屉/对话框**：在查询页新增「API 脚本」侧栏，列表展示已有脚本，提供新建/复制/删除操作；表单字段包含上述配置项，使用 `zod` 验证并即时提示。
- **脚本执行面板**：在结果面板上方新增脚本选择器和「执行」按钮；执行中显示进度条、当前批次详情、成功/失败计数、取消按钮。
- **任务历史**：在侧栏或独立面板展示近期任务记录，支持查看日志及重新导出结果文件。
- **全局任务指示器**：在桌面端顶部导航提供“脚本执行中”提示，跨页面展示核心进度并支持一键跳转或取消任务。

## 数据与存储设计

- `app_prefs` 新增两张表：
  - `query_api_scripts`：`id`, `query_id`, `name`, `description`, `method`, `endpoint`, `headers`(JSON), `fetch_size`, `send_batch_size`, `sleep_ms`, `request_timeout_ms`, `error_policy`, `body_template`, `created_at`, `updated_at`。
  - `query_api_script_runs`：记录每次执行的摘要（脚本快照、状态、生成的文件路径、成功/失败计数、耗时等）。
- TypeScript 接口需与表结构对齐，并在应用加载时同步缓存。

## 桌面后端实现（Tauri Command）

- 新增命令 `execute_api_script`，负责：
  - 接收脚本 ID、查询 SQL、参数和排序信息。
  - 控制数据库分页读取（需保持只读事务，执行 `BEGIN READ ONLY`、`SET LOCAL statement_timeout/idle_in_transaction_session_timeout/search_path`）。
  - 驱动 HTTP 请求（建议使用 `@tauri-apps/api/http` 或 Rust 侧 `reqwest`，在命令层做超时与 header 校验）。
  - 将任务进度通过事件 (`rdv://api-script/run-updated`) 推送到前端，包含批次统计与成功/失败行数。
  - 将结果与日志写入临时目录（`app_cache/api-script-runs/<run_id>/`），最后生成 ZIP 并返回路径。
- 需实现任务队列管理，避免并发执行过多脚本；短期可限制为单任务串行。

## 文件产出与拆分策略

- 数据文件格式：采用 CSV，保留扩展 JSON Lines 的空间以支持后续迭代。
- 当文件行数超过阈值时，启用 `Part-n` 命名拆分；完成后使用 ZIP 并包含 `manifest.json`（记录脚本配置 snapshot、行数、时间戳、错误文件路径等）。
- ZIP 完成后，通过系统文件对话框让用户选择保存位置；若用户取消保存，保留缓存 24 小时后自动清理。

## 错误处理与日志

- 对每个请求记录：批次序号、行范围、请求体摘要、响应状态、耗时、错误信息，写入 `run.log`（JSON Lines）。
- 错误策略：
  - **continue**：记录失败条目到错误文件，继续执行下一批。
  - **abort**：终止任务，返回当前日志与未处理数据提示。
- 对于系统级错误（数据库连接中断、磁盘写入失败）直接中断并提示用户。

## 安全考量

- 对脚本配置中的敏感 header（如 Authorization）设置遮罩展示，仅在执行时解密使用。
- 所有 HTTP 请求默认使用 HTTPS，若用户填写 HTTP 需弹出确认。
- 文件写入路径限定在用户选择的安全目录，避免覆盖现有重要文件。
- 清理策略：任务失败或取消时，自动删除已生成的临时文件；用户可在设置中手动清除历史任务缓存。

## 开发步骤建议

1. **需求细化与确认**：确认请求体模板、重试机制、最大批量限制等细节。
2. **数据层改造**：更新 `app_prefs` schema，编写迁移脚本（仅限应用内 SQLite），并补充读取/写入 DAO 与单测。
3. **前端脚本管理 UI**：实现脚本列表、编辑表单及验证；在查询页加载脚本。
4. **Tauri Command 与任务执行引擎**：实现 Rust 端批处理逻辑、进度事件和结果归档；编写集成测试或模拟测试。
5. **前端任务执行体验**：构建执行面板、进度展示、取消与结果下载。
6. **日志与文件打包**：实现 manifest/zip 生成与清理策略。
7. **QA 与文档**：编写用户操作指南、更新安全清单、补充端到端验证用例。

## 测试策略

- 单元测试：
  - 脚本配置验证（zod schema）。
  - 批处理逻辑（批次拆分、错误策略）可在 Rust 层写 property test。
- 集成测试：使用测试 API mock 服务验证请求节流与超时控制。
- 手动测试：
  - 正常流程（小数据集 + 大数据集）。
  - API 返回错误时继续/中断策略。
  - 文件拆分与 ZIP 导出。
  - 任务取消与恢复。

## 待确认事项

- 请求体模板是否需要脚本化语言（如 Mustache），还是仅支持固定 JSON 结构。
  - 暂时只需要固定的配置结构即可
- 是否允许并发执行多个脚本任务，或限制为单任务。
  - 仅允许单任务，但是要处理当用户切换到其他页面时，任务是否会受影响
- 结果文件格式（JSON Lines vs CSV）是否需要让用户选择。
  - 结果文件暂定 csv 吧
- 外部 API 是否需要认证缓存/重试机制。
  - 暂定，暂时不做
