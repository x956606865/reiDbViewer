name: desktop-bundles

on:
  push:
    tags:
      - 'desktop-v*'
  workflow_dispatch:
    inputs:
      profile:
        description: 'Optional profile name (e.g. nightly, beta)'
        required: false

jobs:
  bundle:
    name: Bundle ${{ matrix.os_label }}
    runs-on: ${{ matrix.runner }}
    env:
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: ubuntu-22.04
            os_label: linux
            artifact_glob: apps/desktop/src-tauri/target/release/bundle/appimage/*.AppImage
          - runner: macos-13
            os_label: macos-x64
            artifact_glob: apps/desktop/src-tauri/target/release/bundle/dmg/*.dmg
          - runner: windows-latest
            os_label: windows
            artifact_glob: apps/desktop/src-tauri/target/release/bundle/nsis/*.exe
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Configure macOS signing environment
        if: runner.os == 'macOS'
        shell: bash
        run: |
          if [ -z "${{ secrets.APPLE_CERTIFICATE }}" ]; then
            echo 'APPLE_CERTIFICATE secret not set, skip signing environment setup.'
            exit 0
          fi

          write_secret() {
            local name="$1"
            local value="$2"
            if [ -n "$value" ]; then
              if [ "$name" = "APPLE_CERTIFICATE" ]; then
                printf '%s<<EOF\n%s\nEOF\n' "$name" "$value" >> "$GITHUB_ENV"
              else
                printf '%s=%s\n' "$name" "$value" >> "$GITHUB_ENV"
              fi
            fi
          }

          write_secret "APPLE_CERTIFICATE" "${{ secrets.APPLE_CERTIFICATE }}"
          write_secret "APPLE_CERTIFICATE_PASSWORD" "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}"
          write_secret "APPLE_TEAM_ID" "${{ secrets.APPLE_TEAM_ID }}"
          write_secret "APPLE_SIGNING_IDENTITY" "${{ secrets.APPLE_SIGNING_IDENTITY }}"
          write_secret "APPLE_PROVIDER_SHORT_NAME" "${{ secrets.APPLE_PROVIDER_SHORT_NAME }}"
          write_secret "APPLE_NOTARIZE_APPLE_ID" "${{ secrets.APPLE_NOTARIZE_APPLE_ID }}"
          write_secret "APPLE_NOTARIZE_PASSWORD" "${{ secrets.APPLE_NOTARIZE_PASSWORD }}"
          write_secret "APPLE_NOTARIZE_TEAM_ID" "${{ secrets.APPLE_NOTARIZE_TEAM_ID }}"

      - name: Configure Windows signing environment
        if: runner.os == 'Windows'
        shell: bash
        run: |
          if [ -z "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" ]; then
            echo 'TAURI_SIGNING_PRIVATE_KEY secret not set, skip signing environment setup.'
            exit 0
          fi

          write_secret() {
            local name="$1"
            local value="$2"
            if [ -n "$value" ]; then
              if [ "$name" = "TAURI_SIGNING_PRIVATE_KEY" ] || [ "$name" = "TAURI_PRIVATE_KEY" ]; then
                printf '%s<<EOF\n%s\nEOF\n' "$name" "$value" >> "$GITHUB_ENV"
              else
                printf '%s=%s\n' "$name" "$value" >> "$GITHUB_ENV"
              fi
            fi
          }

          write_secret "TAURI_SIGNING_PRIVATE_KEY" "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}"
          write_secret "TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}"
          write_secret "TAURI_PRIVATE_KEY" "${{ secrets.TAURI_PRIVATE_KEY }}"
          write_secret "TAURI_KEY_PASSWORD" "${{ secrets.TAURI_KEY_PASSWORD }}"

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin
            ~/.cargo/registry
            ~/.cargo/git
            apps/desktop/src-tauri/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev patchelf
          sudo apt-get install -y libwebkit2gtk-4.1-dev || sudo apt-get install -y libwebkit2gtk-4.0-dev

      - name: Enable Corepack and set pnpm
        run: |
          corepack enable
          corepack prepare pnpm@9 --activate
        shell: bash

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install workspace dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Apple Silicon Rust target
        if: matrix.os_label == 'macos-x64'
        run: rustup target add aarch64-apple-darwin

      - name: Build desktop bundles (host)
        env:
          NODE_OPTIONS: --max_old_space_size=4096
        run: pnpm --filter @rei-db-view/desktop build:tauri

      - name: Separate macOS host artifacts
        if: matrix.os_label == 'macos-x64'
        shell: bash
        run: |
          set -euo pipefail
          bundle_dir="apps/desktop/src-tauri/target/release/bundle"
          if [ -d "$bundle_dir/macos" ]; then
            rm -rf "$bundle_dir/macos-x86_64"
            mv "$bundle_dir/macos" "$bundle_dir/macos-x86_64"
          fi
          if [ -d "$bundle_dir/dmg" ]; then
            rm -rf "$bundle_dir/dmg-x86_64"
            mv "$bundle_dir/dmg" "$bundle_dir/dmg-x86_64"
          fi

      - name: Build desktop bundles (apple silicon)
        if: matrix.os_label == 'macos-x64'
        env:
          NODE_OPTIONS: --max_old_space_size=4096
          SKIP_UI_BUILD: '1'
        run: pnpm --filter @rei-db-view/desktop build:tauri -- --target aarch64-apple-darwin

      - name: Separate macOS apple-silicon artifacts
        if: matrix.os_label == 'macos-x64'
        shell: bash
        run: |
          set -euo pipefail
          bundle_dir="apps/desktop/src-tauri/target/release/bundle"
          if [ -d "$bundle_dir/macos" ]; then
            rm -rf "$bundle_dir/macos-aarch64"
            mv "$bundle_dir/macos" "$bundle_dir/macos-aarch64"
          fi
          if [ -d "$bundle_dir/dmg" ]; then
            rm -rf "$bundle_dir/dmg-aarch64"
            mv "$bundle_dir/dmg" "$bundle_dir/dmg-aarch64"
          fi

      - name: Collect desktop artifacts
        shell: bash
        env:
          BUNDLE_GLOB: "${{ matrix.artifact_glob }}"
          OS_LABEL: "${{ matrix.os_label }}"
        run: |
          set -euo pipefail
          bundle_root="apps/desktop/src-tauri/target"
          staging="$bundle_root/release/ci-artifacts/$OS_LABEL"

          bundle_roots=("$bundle_root/release/bundle")

          manifest_paths=()

          for artifacts_dir in "${bundle_roots[@]}"; do
            if [ ! -d "$artifacts_dir" ]; then
              echo "[updater] directory $artifacts_dir is missing"
              continue
            fi

            # Generate per-platform updater manifests in case the bundler did not emit latest.json
            node apps/desktop/scripts/generate-updater-manifest.mjs --bundle-root "$artifacts_dir"

            while IFS= read -r -d '' manifest_path; do
              manifest_paths+=("$manifest_path")
            done < <(find "$artifacts_dir" -type f -name 'latest.json' -print0)
          done

          if [ ${#manifest_paths[@]} -eq 0 ]; then
            echo "[updater] expected latest.json under ${bundle_roots[*]}"
            exit 1
          fi

          rm -rf "$staging"
          mkdir -p "$staging/updater" "$staging/bundle"

          for manifest_path in "${manifest_paths[@]}"; do
            manifest_dir="$(dirname "$manifest_path")"
            platform_suffix="$(basename "$manifest_dir")"
            dest_dir="$staging/updater/$platform_suffix"
            mkdir -p "$dest_dir"
            cp "$manifest_path" "$dest_dir/latest.json"

            payloads_output="$(
              node -e '
                const fs = require("fs");
                const manifestPath = process.argv[1];
                const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
                const platforms = manifest?.platforms ? Object.values(manifest.platforms) : [];
                const urls = platforms
                  .map((entry) => (entry && typeof entry.url === "string" ? entry.url.trim() : ""))
                  .filter((value) => value.length > 0);
                if (urls.length === 0) process.exit(0);
                process.stdout.write(urls.join("\n"));
              ' "$manifest_path"
            )"

            payloads=()
            if [ -n "$payloads_output" ]; then
              while IFS= read -r payload; do
                [ -z "$payload" ] && continue
                payloads+=("$payload")
              done <<< "$payloads_output"
            fi

            if [ ${#payloads[@]} -eq 0 ]; then
              echo "[updater] manifest $manifest_path does not declare any payload urls"
              exit 1
            fi

            for payload in "${payloads[@]}"; do
              [ -z "$payload" ] && continue
              source_path="$manifest_dir/$payload"
              if [ ! -f "$source_path" ]; then
                echo "[updater] expected payload $source_path referenced by $manifest_path"
                exit 1
              fi

              dest_name="$payload"
              dest="$dest_dir/$dest_name"
              if [ -e "$dest" ]; then
                echo "[updater] duplicate updater payload $(basename "$payload")"
                exit 1
              fi

              cp "$source_path" "$dest"
            done
          done

          bundle_files=()
          shopt -s nullglob
          if [ "$OS_LABEL" = "macos-x64" ]; then
            for root in "${bundle_roots[@]}"; do
              for dmg_dir in "$root"/dmg*; do
                [ -d "$dmg_dir" ] || continue
                for dmg in "$dmg_dir"/*.dmg; do
                  bundle_files+=("$dmg")
                done
              done
              for tar_dir in "$root"/macos*; do
                [ -d "$tar_dir" ] || continue
                for tarball in "$tar_dir"/*.tar.gz; do
                  bundle_files+=("$tarball")
                done
              done
            done
          else
            for resolved in $BUNDLE_GLOB; do
              bundle_files+=("$resolved")
            done
          fi
          shopt -u nullglob

          if [ ${#bundle_files[@]} -eq 0 ]; then
            echo "[bundle] expected artifacts matching glob '$BUNDLE_GLOB'"
            exit 1
          fi

          cp "${bundle_files[@]}" "$staging/bundle/"

          echo "Collected bundles:"
          ls -R "$staging"

      - name: Upload bundle artifacts
        uses: actions/upload-artifact@v4
        with:
          name: reidbview-desktop-${{ matrix.os_label }}
          path: apps/desktop/src-tauri/target/release/ci-artifacts/${{ matrix.os_label }}
          if-no-files-found: error

  publish-release:
    name: Publish release
    runs-on: ubuntu-22.04
    needs: bundle
    if: startsWith(github.ref, 'refs/tags/desktop-v')
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download bundle artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
          pattern: reidbview-desktop-*

      - name: Display downloaded files
        run: ls -R dist

      - name: Set up Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Compose updater manifest
        env:
          UPDATE_PROFILE: ${{ github.event.inputs.profile }}
        run: node apps/desktop/scripts/compose-updater-artifacts.mjs --downloads dist --output dist/updater

      - name: Show updater artifacts
        run: ls -R dist/updater

      - name: Remove per-platform manifests from bundle payloads
        run: find dist -path '*/bundle/latest.json' -type f -delete

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/reidbview-desktop-*/bundle/*
            dist/updater/*
          generate_release_notes: true
          make_latest: true
